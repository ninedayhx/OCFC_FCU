/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * File Name          : app_freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "usart.h"
#include "rtc.h"
#include "adc.h"
#include "i2c.h"
#include "adaptive_pid.h"

#include <string.h>

#include "rs485_display.h"
#include "rs485.h"
#include "rs232.h"
#include "fdcan.h"

#include "w25q64.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
extern uint16_t CAN_RxID;
extern uint8_t CAN_RxDat[8];
extern uint8_t CAN_TtDat[8];

extern UART_ReceiveTypeDef uart1_receive;
extern UART_ReceiveTypeDef uart2_receive;
extern UART_ReceiveTypeDef uart3_receive;
//extern FDCAN_HandleTypeDef hfdcan1;
extern DateTime rtc_time;

AnalogInputs_TypeDef my_analog_inputs;
PCA9555_IO_Status_t ext_io_status;
SysControl_TypeDef sysControl;
DeviceStatus_t Sys_status = DEFAULT_SYS_STATUS;//é»˜è®¤ä¸Šç”µçŠ¶æ??
DeviceFlags_t Sys_flags = {false, false, false, false, false};

extern I2C_HandleTypeDef hi2c1;
extern IWDG_HandleTypeDef hiwdg;
extern TIM_HandleTypeDef htim4;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
osThreadId Display_Task04Handle;
/* USER CODE END Variables */
osThreadId Top_TaskHandle;
osThreadId ActiveExtIO_TasHandle;
osThreadId Analog_Task03Handle;
osTimerId RtosTimer01Handle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */
void SysDataInit(void);
/* USER CODE END FunctionPrototypes */

void Start_Top_Task(void const * argument);
void Start_ActiveExtIO_Task02(void const * argument);
void Start_Analog_Task03(void const * argument);
void RtosCallback01(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* Create the timer(s) */
  /* definition and creation of RtosTimer01 */
  osTimerDef(RtosTimer01, RtosCallback01);
  RtosTimer01Handle = osTimerCreate(osTimer(RtosTimer01), osTimerPeriodic, NULL);

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of Top_Task */
  osThreadDef(Top_Task, Start_Top_Task, osPriorityNormal, 0, 256);
  Top_TaskHandle = osThreadCreate(osThread(Top_Task), NULL);

  /* definition and creation of ActiveExtIO_Tas */
  osThreadDef(ActiveExtIO_Tas, Start_ActiveExtIO_Task02, osPriorityIdle, 0, 128);
  ActiveExtIO_TasHandle = osThreadCreate(osThread(ActiveExtIO_Tas), NULL);

  /* definition and creation of Analog_Task03 */
  osThreadDef(Analog_Task03, Start_Analog_Task03, osPriorityIdle, 0, 180);
  Analog_Task03Handle = osThreadCreate(osThread(Analog_Task03), NULL);

  /* USER CODE BEGIN RTOS_THREADS */


  //å±å¹•æ§åˆ¶å­ç¨‹åº?
//  osThreadDef(Display_Task04, Rs485_Display_Task04, osPriorityIdle, 0, 256);
//  Display_Task04Handle = osThreadCreate(osThread(Display_Task04), NULL);

  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}

/* USER CODE BEGIN Header_Start_Top_Task */
/**
  * @brief  Function implementing the Top_Task thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_Start_Top_Task */
__weak void Start_Top_Task(void const * argument)
{
  /* USER CODE BEGIN Start_Top_Task */
  /* Infinite loop */
	FanControl_TypeDef fan_control;
	PID_Init(&(fan_control.pid), K_P, K_I, K_D, -1.0f, 1.0f, FAN_PWM_MAX_VALUE, -FAN_PWM_MAX_VALUE, 0.1f, 50.0f);
	/**
	* è®¾ç½®æ¸©åº¦å’Œè´Ÿè½½çš„é˜ˆå??
	* å¦‚æœæ¸©åº¦æˆ–è´Ÿè½½è¶…è¿‡äº†é¢„è®¾çš„é˜ˆå€¼ï¼Œ
	* å°±ä¼šè§¦å‘PIDæ§åˆ¶ç®—æ³•ï¼Œè‡ªåŠ¨å¢åŠ é£æ‰‡çš„è½¬é?Ÿï¼Œ
	* ä»¥é˜²æ­¢æ¸©åº¦ç»§ç»­ä¸Šå‡æˆ–è´Ÿè½½è¿‡å¤§
	*/
	fan_control.temp_threshold = 30.0f;
	fan_control.load_threshold = 0.0f;
	// è®¾ç½®åˆå§‹é£æ‰‡è½¬ï¿½??
	fan_control.fan_speed = 0;

	//å¼?é˜?è®¡æ—¶ï¿???
	uint32_t Exhaust_O_start_time = 0;
	uint32_t Exhaust_O_current_time = 0;
	//å…³é˜€è®¡æ—¶ï¿???
	uint32_t Exhaust_C_start_time = 0;
	uint32_t Exhaust_C_current_time = 0;
	bool ExhaustFlag = false;

	osDelay(200);
	sysControl.Expected_FC_Fan_Enable = 0;

	uint32_t count = HAL_GetTick();//è·å–ç³»ç»Ÿæ—¶é—´

#ifdef DEFAULT_SYS_TWOFC
	uint8_t analogInputs_count_a = 0;
	uint8_t analogInputs_count_b = 0;
	uint8_t a_fanspeed = 0;
	uint8_t b_fanspeed = 0;
#else
	uint8_t analogInputs_count = 0;

#endif

	//å†…éƒ¨flashæµ‹è¯•--
	//RS232_1_printf(" read i = %d \r\n",ReadFlash(ADDR_FLASH_SECTOR_5));
//	uint32_t addr = 0x08070000;
//	HAL_FLASH_Unlock();
//	stmflash_erase_sector(addr);
//	uint16_t status = HAL_FLASH_Program(0x00000002U, addr, 0x01f360b45);
//	HAL_FLASH_Lock();
//	uint32_t applength = *(uint32_t *)addr;
//	RS232_1_printf("Writeflash:%x\r\n",applength);
//	RS232_1_printf("Readflash:%x\r\n",status);
	//å¤–éƒ¨flashæµ‹è¯•-----------
//	uint8_t device_id[3];
//	uint8_t read_buf[10] = {0};
//	uint8_t write_buf[10] = {0};
//	int i;
//	Read_Jedec_ID((uint8_t *)device_id);
//	RS232_1_printf("W25Q64 ID 0x%x, 0x%x, 0x%x\r\n", device_id[0], device_id[1], device_id[2]);
//	/* ä¸ºäº†éªŒè¯ï¼Œé¦–å…ˆè¯»å–è¦å†™å…¥åœ°å€å¤„çš„æ•°æ® */
//	RS232_1_printf("-------- read data before write -----------\r\n");
//	Read_Data(0, read_buf, 10);
//	for(i = 0; i < 10; i++){
//	  RS232_1_printf("[0x%08x]:0x%02x\r\n", i, *(read_buf+i));
//	}
//	/* æ“¦é™¤è¯¥æ‰‡åŒ? */
//	RS232_1_printf("\r\n-------- erase sector 0 -----------\r\n");
//	Sector_Erase(0);
//	/* å†æ¬¡è¯»æ•°æ? */
//	RS232_1_printf("-------- read data after erase -----------\r\n");
//	Read_Data(0, read_buf, 10);
//	for(i = 0; i < 10; i++){
//	  RS232_1_printf("[0x%08x]:0x%02x\r\n", i, *(read_buf+i));
//	}
//	/* å†™æ•°æ?1ï¼Œæ“¦é™¤æ‰‡åŒºåçš„å†™å…? */
//	RS232_1_printf("\r\n-------- write data 11111 -----------\r\n");
//	for(i = 0; i < 10; i++){
//	write_buf[i] = i;
//	}
//	Page_Write(0, write_buf, 10);
//	/* å†æ¬¡è¯»æ•°æ? */
//	RS232_1_printf("-------- read data after write -----------\r\n");
//	Read_Data(0, read_buf, 10);
//	for(i = 0; i < 10; i++){
//	  RS232_1_printf("[0x%08x]:0x%02x\r\n", i, *(read_buf+i));
//	}
//
//	//	Sector_Erase(0);
//	/* å†™æ•°æ?2ï¼Œæœªæ“¦é™¤è¿ç»­å†™å…¥ï¼Œè§‚å¯Ÿæœªæ“¦é™¤èƒ½å¦å†™å…¥ */
//	RS232_1_printf("\r\n-------- write data 22222 -----------\r\n");
//	for(i = 0; i < 10; i++){
//	write_buf[i] = i*16;
//	}
//	Page_Write(0, write_buf, 10);
//
//	/* å†æ¬¡è¯»æ•°æ? */
//	RS232_1_printf("-------- read data after write -----------\r\n");
//	Read_Data(0, read_buf, 10);
//	for(i = 0; i < 10; i++){
//	  RS232_1_printf("[0x%08x]:0x%02x\r\n", i, *(read_buf+i));
//	}

	while(true)
	{

		process_RS232_uart1_command();
		osDelay(20);
		// æ›´æ–°é£æ‰‡æ§åˆ¶ï¿???
		//FanControl_Update(&fan_control, my_analog_inputs.FC_Internal_Temperature.Current_Val, 0);


		//RS232_1_printf("$Tick: %d\n", HAL_GetTick());
		//æ’æ°”ï¿???æ§åˆ¶

		sysControl.Expected_Heatsink_Fan_Enable = true;

		//FCUçŠ¶ï¿½?ï¿½æœº
		switch(Sys_status) {
			case DEVICE_STOPPED://ç³»ç»Ÿåœæœº
#ifdef DEFAULT_SYS_TWOFC
				/*----------------åŒå †åœæœºæµç¨‹-------------------*/
				//å¦‚æœç³»ç»Ÿæ­£åœ¨è¿è¡Œ,è¿›å…¥ä»¥ä¸‹åœæœºæµç¨‹
				if(Sys_flags.device_started){

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);
					RS232_1_printf("TwoFC_System is shutting down! Please wait.....\n");

					//2.å…³é—­ä¸»DCDC
					sysControl.Expected_DCDC_Enable = false;
					osDelay(1000);
					//2.å…³é—­æ°¢æ°”è¿›æ°”ï¿???
					sysControl.Expected_Hydrogen_Inlet_Valve_Enable = false;
					osDelay(2000);
					//3.é£æ‰‡è½¬ï¿½?ï¿½ç¼“å‡åˆ°0
					while(sysControl.Expected_FC_Fan_Speed > 0){
						sysControl.Expected_FC_Fan_Speed --;
						osDelay(100);
					}
					//3.å…³é—­ä¸»é£æ‰‡ç”µï¿???
					sysControl.Expected_FC_Fan_Enable = false;
					//4.å…³é—­ç”µå †è¾“å‡ºæ¥è§¦ï¿???
					sysControl.Expected_Contactor_Fc_Enable = false;
					sysControl.Expected_Contactor_Load_Enable = false;
					//ç³»ç»ŸçŠ¶ï¿½?ï¿½æ ‡å¿—ä½æ¸…é›¶
					Sys_flags.device_started = false;

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);
					RS232_1_printf("TwoFC_System has shut down successfully.\n");
				}

#else
				/*----------------å•å †åœæœºæµç¨‹-------------------*/
				//å¦‚æœç³»ç»Ÿæ­£åœ¨è¿è¡Œ,è¿›å…¥ä»¥ä¸‹åœæœºæµç¨‹
				if(Sys_flags.device_started){

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);
					RS232_1_printf("System is shutting down! Please wait.....\n");

					//1.å…³é—­ç»ˆç«¯è´Ÿè½½æ¥è§¦ï¿???
					sysControl.Expected_Contactor_Load_Enable = false;
					osDelay(3000);
					//2.å…³é—­ä¸»DCDC
					sysControl.Expected_DCDC_Enable = false;
					osDelay(1000);
					//2.å…³é—­æ°¢æ°”è¿›æ°”ï¿???
					sysControl.Expected_Hydrogen_Inlet_Valve_Enable = false;
					osDelay(2000);
					//3.é£æ‰‡è½¬ï¿½?ï¿½ç¼“å‡åˆ°0
					while(sysControl.Expected_FC_Fan_Speed > 0){
						sysControl.Expected_FC_Fan_Speed --;
						osDelay(100);
					}
					//3.å…³é—­ä¸»é£æ‰‡ç”µï¿???
					sysControl.Expected_FC_Fan_Enable = false;
					//4.å…³é—­ç”µå †è¾“å‡ºæ¥è§¦ï¿???
					sysControl.Expected_Contactor_Fc_Enable = false;
					//ç³»ç»ŸçŠ¶ï¿½?ï¿½æ ‡å¿—ä½æ¸…é›¶
					Sys_flags.device_started = false;

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);
					RS232_1_printf("System has shut down successfully.\n");
				}
#endif


				break;

			case DEVICE_RUNNING://ç³»ç»Ÿå¯åŠ¨
#ifdef DEFAULT_SYS_TWOFC
				/*-----------------åŒå †å¯åŠ¨æµç¨‹-----------------*/
				//å¦‚æœç³»ç»Ÿæœªå¯åŠ?,è¿›å…¥ä»¥ä¸‹åŒå †å¯åŠ¨æµç¨‹
				if(!Sys_flags.device_started){

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);

					RS232_1_printf("TwoFC_System is starting up! Please wait.....\n");
					//1.å¼?å¯ä¸»é£æ‰‡ç”µæº
					sysControl.Expected_FC_Fan_Enable = true;
					osDelay(1000);
					sysControl.Expected_FC_Fan_Speed = 99;//é£æ‰‡è½¬é??
					osDelay(500);
					//2.å¼?å¯æ°¢æ°”è¿›æ°”é˜€
					sysControl.Expected_Hydrogen_Inlet_Valve_Enable = true;
					osDelay(1000);
					//3.å¼?å¯ç”µå †è¾“å‡ºæ¥è§¦å™¨
					sysControl.Expected_Contactor_Fc_Enable = true;
					osDelay(300);
					sysControl.Expected_Contactor_Load_Enable = true;
					osDelay(700);
					//4.å¼?å¯ä¸»DCDC
					sysControl.Expected_DCDC_Enable = true;
					osDelay(1000);
					//6.
					//è®¾ç½®ç³»ç»ŸçŠ¶æ?æ ‡å¿—ä½ å·²å¯åŠ?
					Sys_flags.device_started = true;

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);
					RS232_1_printf("TwoFC_System has started successfully.\n");
				}
#else
				/*-----------------å•å †å¯åŠ¨æµç¨‹-----------------*/
				//å¦‚æœç³»ç»Ÿæœªå¯åŠ?,è¿›å…¥ä»¥ä¸‹å•å †å¯åŠ¨æµç¨‹
				if(!Sys_flags.device_started){

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);

					RS232_1_printf("System is starting up! Please wait.....\n");
					//1.ï¿???å¯ä¸»é£æ‰‡ç”µæº
					sysControl.Expected_FC_Fan_Enable = true;
					osDelay(1000);
					sysControl.Expected_FC_Fan_Speed = 99;//é£æ‰‡ï¿???ï¿???
					osDelay(500);
					//2.ï¿???å¯æ°¢æ°”è¿›æ°”é˜€
					sysControl.Expected_Hydrogen_Inlet_Valve_Enable = true;
					osDelay(1000);
					//3.ï¿???å¯ç”µå †è¾“å‡ºæ¥è§¦å™¨
					sysControl.Expected_Contactor_Fc_Enable = true;
					osDelay(1000);
					//4.ï¿???å¯ä¸»DCDC
					sysControl.Expected_DCDC_Enable = true;
					osDelay(1000);
					//5.ï¿???å¯ç»ˆç«¯è´Ÿè½½æ¥è§¦å™¨ å¯¹å¤–è¾“å‡º
					sysControl.Expected_Contactor_Load_Enable = true;
					//6.
					//è®¾ç½®ç³»ç»ŸçŠ¶ï¿½?ï¿½æ ‡å¿—ä½ å·²å¯ï¿???
					Sys_flags.device_started = true;

					getRtcDateTime(&rtc_time.year, &rtc_time.month, &rtc_time.day, &rtc_time.hour, &rtc_time.min, &rtc_time.sec, &rtc_time.ms);
					RS232_1_printf("<$-%04d/%02d/%02d-%02d:%02d:%02d.%03d-$>", rtc_time.year, rtc_time.month, rtc_time.day, rtc_time.hour, rtc_time.min, rtc_time.sec, rtc_time.ms);
					RS232_1_printf("System has started successfully.\n");
				}
#endif

				/*---------------ä¸»é£æ‰‡åŠ¨æ€æ§ï¿???---------------*/
				//PIDè®¾ç½®ç›®æ ‡ï¿???
				//fan_control.pid.setpoint = my_analog_inputs.FC_External_Temperature.Current_Val;
				//FanControl_Update(&fan_control, my_analog_inputs.FC_Internal_Temperature.Current_Val);
				//RS232_1_printf("$Pid=%f\r\n",PID_Update(&(fan_control.pid), my_analog_inputs.FC_Internal_Temperature.Current_Val));
				//éé˜»å¡æ§åˆ¶æ’æ°”é˜€å»¶æ—¶é€šæ–­
				if(!ExhaustFlag){//å¦‚æœæ’æ°”ï¿???æ˜¯å…³é—­çŠ¶ï¿???
				  Exhaust_O_start_time = HAL_GetTick();//å¼?å¯æ’æ°”é˜€ è·å–å½“å‰ç³»ç»Ÿæ—¶é—´
				  if ((Exhaust_O_start_time - Exhaust_O_current_time) >= FC_EXHAUST_PERIED) {
					  sysControl.Expected_Hydrogen_Exhaust_Valve_Enable = true;
					  Exhaust_O_current_time = Exhaust_O_start_time;//åŒæ­¥åˆ°ç³»ç»Ÿæ—¶ï¿???
					  Exhaust_C_current_time = Exhaust_O_current_time;
					  ExhaustFlag = true;
					  AnimationPlayFrame(1,7,DISPLAY_ICON_G);
				  }
				}else{
				  Exhaust_C_start_time =  HAL_GetTick();//å…³é—­æ’æ°”é˜? è·å–å½“å‰ç³»ç»Ÿæ—¶é—´
				  if ((Exhaust_C_start_time - Exhaust_C_current_time) >= FC_EXHAUST_TIME){
					  sysControl.Expected_Hydrogen_Exhaust_Valve_Enable = false;
					  Exhaust_C_current_time = Exhaust_C_start_time;
					  ExhaustFlag = false;
					  AnimationPlayFrame(1,7,DISPLAY_ICON_Y);
				  }
				}
#ifdef DEFAULT_SYS_TWOFC
				//--------------------------åŒå †ä¿æŠ¤ç­–ç•¥-------------------------------
				if(count + 200 <= HAL_GetTick())
				{	//ç‡ƒæ–™ç”µæ± ç”µå‹ä½äºFC_LOLO_Vï¼Œæˆ–è€…ç”µå †æ¸©åº¦è¶…è¿‡FC_HIHI_TEMP
					//å…³é—­å¯¹å¤–è´Ÿè½½æ¥è§¦å™?
					if			(my_analog_inputs.FC_Internal_Temperature.Current_Val >= FC_HIHI_TEMP){
						sysControl.Expected_Contactor_Fc_Enable = false;//å †Aæ¸©åº¦è¶…è¿‡FC_HIHI_TEMPå…³é—­å †Aè¾“å‡º
					}else if	(my_analog_inputs.FC_External_Temperature.Current_Val >= FC_HIHI_TEMP){
						sysControl.Expected_Contactor_Load_Enable = false;//å †Bæ¸©åº¦è¶…è¿‡FC_HIHI_TEMPå…³é—­å †Bè¾“å‡º
					}
					else if(my_analog_inputs.Shunt_A_Voltage.Current_Val <= A_FC_LOLO_V){
						analogInputs_count_a += 1;
						if(analogInputs_count_a >= 20){
							sysControl.Expected_Contactor_Fc_Enable = false;
							analogInputs_count_a = 0;
						}
					}else if(my_analog_inputs.Shunt_B_Voltage.Current_Val <= B_FC_LOLO_V){
						analogInputs_count_b += 1;
						if(analogInputs_count_b >= 20){
							sysControl.Expected_Contactor_Load_Enable = false;
							analogInputs_count_b = 0;
						}
					}
					else{
						sysControl.Expected_Contactor_Fc_Enable =true;
						osDelay(10);
						sysControl.Expected_Contactor_Load_Enable = true;
					}

					//é£æ‰‡è½¬é?Ÿæ§åˆ?  a>b?a:b
					a_fanspeed = calculateFanSpeed(
						my_analog_inputs.FC_Internal_Temperature.Current_Val,
						my_analog_inputs.Shunt_A_Power.Current_Val);
					b_fanspeed = calculateFanSpeed(
						my_analog_inputs.FC_Internal_Temperature.Current_Val,
						my_analog_inputs.Shunt_B_Power.Current_Val);
					if(a_fanspeed >= b_fanspeed){
						sysControl.Expected_FC_Fan_Speed = a_fanspeed;
					}else{
						sysControl.Expected_FC_Fan_Speed = b_fanspeed;
					}
					//sysControl.Expected_FC_Fan_Speed = a_fanspeed > b_fanspeed ? a_fanspeed : b_fanspeed;

					count = HAL_GetTick();
				}
#else
				//--------------------------å•å †ä¿æŠ¤ç­–ç•¥-------------------------------
				if(count + 200 <= HAL_GetTick())
				{	//ç‡ƒæ–™ç”µæ± ç”µå‹ä½äºFC_LOLO_Vï¼Œæˆ–è€…ç”µå †æ¸©åº¦è¶…è¿‡FC_HIHI_TEMP
					//å…³é—­å¯¹å¤–è´Ÿè½½æ¥è§¦å™?
					if(my_analog_inputs.FC_Internal_Temperature.Current_Val >= FC_HIHI_TEMP)
					{
						sysControl.Expected_Contactor_Fc_Enable = false;
					}
					else if(my_analog_inputs.Shunt_A_Voltage.Current_Val <= FC_LOLO_V)
					{

						analogInputs_count += 1;

						if(analogInputs_count >= 20)
						{
							sysControl.Expected_Contactor_Fc_Enable = false;
							analogInputs_count = 0;
						}

						//sysControl.Expected_Contactor_Fc_Enable =false;
					}
					else
					{
						sysControl.Expected_Contactor_Fc_Enable =true;
						sysControl.Expected_Contactor_Load_Enable = true;
					}

					//é£æ‰‡è½¬é?Ÿæ§åˆ?
					sysControl.Expected_FC_Fan_Speed = calculateFanSpeed(
						my_analog_inputs.FC_Internal_Temperature.Current_Val,
						my_analog_inputs.Shunt_B_Power.Current_Val);

					count = HAL_GetTick();
				}
#endif

				break;

			case DEVICE_STANDBY://ç³»ç»Ÿå¾…æœº
				RS232_1_printf("Device is in standby mode\n");

				break;

			case DEVICE_ERROR://ç³»ç»Ÿé”™è¯¯
				RS232_1_printf("Device is in error state\n");

				break;

			case DEVICE_FAULT://ç³»ç»Ÿæ•…éšœ
				RS232_1_printf("Device is in fault state\n");

				break;

			default:
				//æœªçŸ¥è®¾å¤‡çŠ¶ï¿½??
				RS232_1_printf("Unknown device status\n");
				break;
		}

		//sysControl.Expected_FC_Fan_Speed = sysControl.Expected_FC_Fan_Speed - PID_Update(&(fan_control.pid), my_analog_inputs.FC_Internal_Temperature.Current_Val);
		//	  for(uint16_t i = 0; i < 4096 ; i++){
		//		  RS232_1_printf("$Shunt:D=%d,C=%.2f\r\n",i,convert_adc_to_current(i, 3.3, 75));
		//		  osDelay(10);
		//	  }
		//sysControl.Expected_FC_Fan_Speed = (sysControl.Expected_FC_Fan_Speed + 1) % 101;
		//	  FC_Fan_Close;
		//	  sysControl.Expected_FC_Fan_Enable = 0;
		//	  osDelay(1200);
		//	  FC_Fan_Open;
		//	  sysControl.Expected_FC_Fan_Enable = 1;
		//	  sysControl.Expected_FC_Fan_Speed = 12;
		//	  osDelay(2000);
	}
  /* USER CODE END Start_Top_Task */
}

/* USER CODE BEGIN Header_Start_ActiveExtIO_Task02 */
/**
* @brief Function implementing the ActiveExtIO_Tas thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_Start_ActiveExtIO_Task02 */
__weak void Start_ActiveExtIO_Task02(void const * argument)
{
  /* USER CODE BEGIN Start_ActiveExtIO_Task02 */
	uint8_t pca9555_device_address = PCA9555_Get_Device_Address(PCA9555_A2, PCA9555_A1, PCA9555_A0, 0); // è·å–PCA9555çš„è®¾å¤‡åœ°ï¿???
	for(uint8_t i = 0 ; i < 3 ; i++ ){
		PCA9555_Init(&hi2c1, pca9555_device_address); // åˆå§‹åŒ–PCA9555
		PCA9555_Set_IO_Mode(&hi2c1, pca9555_device_address, 0x0080); // è®¾ç½®IOå£æ¨¡ï¿???,Port0æ˜¯è¾“å‡ºæ¨¡å¼ï¼ŒPort1æ˜¯è¾“å…¥æ¨¡ï¿???
		osDelay(50);
		PCA9555_Write_IO_State(&hi2c1, pca9555_device_address, 0x0F);
	}
	ext_io_status.pca9555_current_state = 0x0F;
	ext_io_status.pca9555_expected_state = 0x0F;

	uint8_t Current_FC_Fan_Speed = sysControl.Expected_FC_Fan_Speed;										//å½“å‰ï¿??? FCä¸»é£æ‰‡è½¬ï¿??? PWM å ç©ºï¿??? 0-100%
	bool Current_FC_Fan_Enable = sysControl.Expected_FC_Fan_Enable;										//å½“å‰ï¿??? FCä¸»é£æ‰‡ä½¿ï¿???
	bool Current_DCDC_Enable = sysControl.Expected_DCDC_Enable;												//å½“å‰ï¿??? DCDCä½¿èƒ½
	bool Current_Heatsink_Fan_Enable = sysControl.Expected_Heatsink_Fan_Enable;							//å½“å‰ï¿??? FCUæ•£çƒ­é£æ‰‡ä½¿èƒ½
	bool Current_Hydrogen_Inlet_Valve_Enable = sysControl.Expected_Hydrogen_Inlet_Valve_Enable;		//å½“å‰ï¿??? æ°¢æ°”è¿›æ°”ï¿???ä½¿èƒ½
	bool Current_Hydrogen_Exhaust_Valve_Enable = sysControl.Expected_Hydrogen_Exhaust_Valve_Enable;	//å½“å‰ï¿??? æ°¢æ°”æ’æ°”ï¿???ä½¿èƒ½
	bool Current_Contactor_Fc_Enable = sysControl.Expected_Contactor_Fc_Enable;							//å½“å‰ï¿??? ç‡ƒæ–™ç”µæ± æ¥è§¦å™¨Aä½¿èƒ½
	bool Current_Contactor_Load_Enable = sysControl.Expected_Contactor_Load_Enable;						//å½“å‰ï¿??? ç»ˆç«¯è´Ÿè½½æ¥è§¦å™¨Bä½¿èƒ½

	FC_Fan_Close;
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, htim4.Init.Period - 10);

	/* Infinite loop */
	while(true){
		//ä¸»é£æ‰‡è½¬é€ŸçŠ¶æ€æ›´ï¿???
		if(sysControl.Expected_FC_Fan_Speed != Current_FC_Fan_Speed){
			if(sysControl.Expected_FC_Fan_Speed > 99)sysControl.Expected_FC_Fan_Speed = 99;
			//å°†å ç©ºæ¯”å–å,ç»è¿‡å…‰ï¿½?ï¿½å†ç¿»è½¬ä¸ºæ­£å ç©ºï¿???(å®šæ—¶å™¨å‘¨æœŸå‡å»æ­£å ç©ºæ¯”çš„å€¼ï¼Œå³ä¸ºè´Ÿå ç©ºæ¯”å€¼ï¿½??)
			__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, htim4.Init.Period - map_0_to_100_to_12_to_100(sysControl.Expected_FC_Fan_Speed));
			Current_FC_Fan_Speed = sysControl.Expected_FC_Fan_Speed;
		}
		//ä¸»é£æ‰‡ä½¿èƒ½çŠ¶æ€æ›´ï¿???
		if(sysControl.Expected_FC_Fan_Enable != Current_FC_Fan_Enable){
			if(sysControl.Expected_FC_Fan_Enable){
				FC_Fan_Open;
				Current_FC_Fan_Enable = sysControl.Expected_FC_Fan_Enable;
			}else{
				FC_Fan_Close;
				Current_FC_Fan_Enable = sysControl.Expected_FC_Fan_Enable;
			}
		}
		//DCDCä½¿èƒ½çŠ¶ï¿½?ï¿½æ›´ï¿???
		if(sysControl.Expected_DCDC_Enable != Current_DCDC_Enable){
			if(sysControl.Expected_DCDC_Enable){
				DCDC_Open;
				Current_DCDC_Enable = sysControl.Expected_DCDC_Enable;
			}else{
				DCDC_Close;
				Current_DCDC_Enable = sysControl.Expected_DCDC_Enable;
			}
		}
		//è¾…åŠ©é£æ‰‡çŠ¶ï¿½?ï¿½æ›´ï¿???
		if(sysControl.Expected_Heatsink_Fan_Enable != Current_Heatsink_Fan_Enable){
			if(sysControl.Expected_Heatsink_Fan_Enable){
				Heatsink_Fan_Open;
				Current_Heatsink_Fan_Enable = sysControl.Expected_Heatsink_Fan_Enable;
			}else{
				Heatsink_Fan_Close;
				Current_Heatsink_Fan_Enable = sysControl.Expected_Heatsink_Fan_Enable;
			}
		}
		//æ°¢æ°”è¿›æ°”ï¿???çŠ¶ï¿½?ï¿½æ›´ï¿???
		if(sysControl.Expected_Hydrogen_Inlet_Valve_Enable != Current_Hydrogen_Inlet_Valve_Enable){
			if(sysControl.Expected_Hydrogen_Inlet_Valve_Enable){
				Hydrogen_Inlet_Valve_Open;
				Current_Hydrogen_Inlet_Valve_Enable = sysControl.Expected_Hydrogen_Inlet_Valve_Enable;
			}else{
				Hydrogen_Inlet_Valve_Close;
				Current_Hydrogen_Inlet_Valve_Enable = sysControl.Expected_Hydrogen_Inlet_Valve_Enable;
			}
		}
		//æ°¢æ°”æ’æ°”ï¿???çŠ¶ï¿½?ï¿½æ›´ï¿???
		if(sysControl.Expected_Hydrogen_Exhaust_Valve_Enable != Current_Hydrogen_Exhaust_Valve_Enable){
			if(sysControl.Expected_Hydrogen_Exhaust_Valve_Enable){
				Hydrogen_Exhaust_Valve_Open;
				Current_Hydrogen_Exhaust_Valve_Enable = sysControl.Expected_Hydrogen_Exhaust_Valve_Enable;
			}else{
				Hydrogen_Exhaust_Valve_Close;
				Current_Hydrogen_Exhaust_Valve_Enable = sysControl.Expected_Hydrogen_Exhaust_Valve_Enable;
			}
		}
		//ç‡ƒæ–™ç”µæ± è¾“å‡ºç«¯æ¥è§¦å™¨çŠ¶ï¿½?ï¿½æ›´ï¿???
		if(sysControl.Expected_Contactor_Fc_Enable != Current_Contactor_Fc_Enable){
			if(sysControl.Expected_Contactor_Fc_Enable){
				Contactor_Fc_Open;
				Current_Contactor_Fc_Enable = sysControl.Expected_Contactor_Fc_Enable;
			}else{
				Contactor_Fc_Close;
				Current_Contactor_Fc_Enable = sysControl.Expected_Contactor_Fc_Enable;
			}
		}
		//ç»ˆç«¯è´Ÿè½½æ¥è§¦å™¨çŠ¶æ€æ›´ï¿???
		if(sysControl.Expected_Contactor_Load_Enable != Current_Contactor_Load_Enable){
			if(sysControl.Expected_Contactor_Load_Enable){
				Contactor_Load_Open;
				Current_Contactor_Load_Enable = sysControl.Expected_Contactor_Load_Enable;
			}else{
				Contactor_Load_Close;
				Current_Contactor_Load_Enable = sysControl.Expected_Contactor_Load_Enable;
			}
		}
		//Pca9555è¾“å‡ºç®¡è„šçŠ¶ï¿½?ï¿½æ›´ï¿???
		if(ext_io_status.pca9555_current_state != ext_io_status.pca9555_expected_state){
			PCA9555_Write_IO_State(&hi2c1, pca9555_device_address, ext_io_status.pca9555_expected_state);
			ext_io_status.pca9555_current_state = ext_io_status.pca9555_expected_state;
		}
		osDelay(1);
	}
  /* USER CODE END Start_ActiveExtIO_Task02 */
}

/* USER CODE BEGIN Header_Start_Analog_Task03 */
/**
* @brief Function implementing the Analog_Task03 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_Start_Analog_Task03 */
__weak void Start_Analog_Task03(void const * argument)
{
  /* USER CODE BEGIN Start_Analog_Task03 */
	uint32_t count = HAL_GetTick();//è·å–ç³»ç»Ÿæ—¶é—´

	resetFlowMeter();//æµé‡è®¡ç´¯è®¡æ¸…ï¿??
  /* Infinite loop */
  while(true)
  {
	  // è¯»å–æ‰?æœ‰ADé€šé“ADå€?
	  read_all_adc1_values(my_analog_inputs.adc1_values, 5);
	  read_all_adc2_values(my_analog_inputs.adc2_values, 4);
	  //ADå€¼è½¬æ¢ä¸ºç‰©ç†é‡?
	  my_analog_inputs.Power_Voltage.Current_Val = convert_adc_to_voltage(my_analog_inputs.adc1_values[0], 3.262, 0.022);//ç”µå‹è½¬æ¢
	  my_analog_inputs.External_Hydrogen_Concentration.Current_Val = my_analog_inputs.adc1_values[1] /40.96;//æµ“åº¦ppm
	  my_analog_inputs.Hydrogen_Cylinder_Pressure.Current_Val = (( my_analog_inputs.adc1_values[2] * 0.001221) - 0.5 ) * 12.5 ;//æ°”å‹è½¬æ¢
	  my_analog_inputs.FC_Internal_Temperature.Current_Val = Get_Tempture(my_analog_inputs.adc1_values[3],10000,10020); //å †å†…æ¸©åº¦è½¬æ¢
	  my_analog_inputs.FC_External_Temperature.Current_Val = Get_Tempture(my_analog_inputs.adc1_values[4],10000,10020); //å †å¤–
	  my_analog_inputs.Shunt_A_Current.Current_Val = convert_adc_to_current(my_analog_inputs.adc2_values[0], 3.264, 75);// shunt A ç”µå †è¾“å‡º
	  my_analog_inputs.Shunt_A_Voltage.Current_Val = convert_adc_to_voltage(my_analog_inputs.adc2_values[1], 3.262, 0.019);
	  my_analog_inputs.Shunt_B_Current.Current_Val = convert_adc_to_current(my_analog_inputs.adc2_values[2], 3.264, 75); // shunt B è´Ÿè½½è¾“å‡º
	  my_analog_inputs.Shunt_B_Voltage.Current_Val = convert_adc_to_voltage(my_analog_inputs.adc2_values[3], 3.262, 0.0213);
	  //å®æ—¶åŠŸç‡ä¸ç”µèƒ½è®¡è½¬æ¢
	  my_analog_inputs.Shunt_A_Power.Current_Val = power_calculation(my_analog_inputs.Shunt_A_Voltage.Current_Val , my_analog_inputs.Shunt_A_Current.Current_Val);
	  my_analog_inputs.Shunt_A_Total_Energy.Current_Val += energy_calculation(my_analog_inputs.Shunt_A_Power.Current_Val , SAMPLING_INTERVAL);
	  my_analog_inputs.Shunt_B_Power.Current_Val = power_calculation(my_analog_inputs.Shunt_B_Voltage.Current_Val , my_analog_inputs.Shunt_B_Current.Current_Val);
	  my_analog_inputs.Shunt_B_Total_Energy.Current_Val += energy_calculation(my_analog_inputs.Shunt_B_Power.Current_Val , SAMPLING_INTERVAL);

#ifdef RS485_FLOWMETER
	  if(count + DELAY_TIME <= HAL_GetTick()){
		  queryFlowMeter();//è·å–æµé‡è®¡ç¬æ—¶ä¸ç´¯è®¡æµé‡
		  count = HAL_GetTick();
	  }
#endif



	#ifdef USE_DEBUG_ANALOG
	  RS232_1_printf("$ADC1_0=%d,$ADC1_1=%d,$ADC1_2=%d,$ADC1_3=%d,$ADC1_4=%d,",
			  my_analog_inputs.adc1_values[0],
			  my_analog_inputs.adc1_values[1],
			  my_analog_inputs.adc1_values[2],
			  my_analog_inputs.adc1_values[3],
			  my_analog_inputs.adc1_values[4]
		);
	  RS232_1_printf("$ADC2_0=%d,$ADC2_1=%d,$ADC2_2=%d,$ADC2_3=%d\r\n",
			  my_analog_inputs.adc2_values[0],
			  my_analog_inputs.adc2_values[1],
			  my_analog_inputs.adc2_values[2],
			  my_analog_inputs.adc2_values[3]
		);
	#endif

/**
 * é‡‡æ ·èŒƒå›´
 * $PowV=			0-120.00V, 	å€ç‡100		uint16_t
 * $ExtHC=			0-100.00%,
 * $HCP=			0-65.00Mpa,
 * $FcTemp=		0-80.00â„?,		å€ç‡100
 * $ExtTemp=		0-80.00â„?,		å€ç‡100
 * $ShuntA_C=		0-100.00A,	å€ç‡100
 * $ShuntA_V=		0-120.00V,	å€ç‡100
 * $ShuntB_C=		0-100.00A,	å€ç‡100
 * $ShuntB_V=		0-120.00V,	å€ç‡100
 * $ShuntA_Power=0-100.00KW,	å€ç‡100
 * $ShuntA_Total=0-100.00KWh,	å€ç‡100
 * $ShuntB_Power=0-100.00KW,	å€ç‡100
 * $ShuntB_Total=0-100.00KWh,	å€ç‡100
 */
	//FDCAN1_Send_Msg(can_Tdat,FDCAN_DLC_BYTES_8);

    osDelay(SAMPLING_INTERVAL);
    HAL_IWDG_Refresh(&hiwdg);//å–‚ç‹— è¶…è¿‡2så¤ä½
  }
  /* USER CODE END Start_Analog_Task03 */
}

/* RtosCallback01 function */
__weak void RtosCallback01(void const * argument)
{
  /* USER CODE BEGIN RtosCallback01 */

  /* USER CODE END RtosCallback01 */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

void SysDataInit(void){
//	sysControl.Expected_FC_Fan_Speed = 0;				//å½“å‰ï¿??? FCä¸»é£æ‰‡è½¬ï¿??? PWM å ç©ºï¿??? 0-100%
//	sysControl.Expected_FC_Fan_Enable = true;						//å½“å‰ï¿??? FCä¸»é£æ‰‡ä½¿ï¿???
//	sysControl.Expected_DCDC_Enable;							//å½“å‰ï¿??? DCDCä½¿èƒ½
//	sysControl.Expected_Heatsink_Fan_Enable;				//å½“å‰ï¿??? FCUæ•£çƒ­é£æ‰‡ä½¿èƒ½
//	sysControl.Expected_Hydrogen_Inlet_Valve_Enable;		//å½“å‰ï¿??? æ°¢æ°”è¿›æ°”ï¿???ä½¿èƒ½
//	sysControl.Expected_Hydrogen_Exhaust_Valve_Enable;	//å½“å‰ï¿??? æ°¢æ°”æ’æ°”ï¿???ä½¿èƒ½
//	sysControl.Expected_Contactor_Fc_Enable;				//å½“å‰ï¿??? ç‡ƒæ–™ç”µæ± æ¥è§¦å™¨Aä½¿èƒ½
//	sysControl.Expected_Contactor_Load_Enable;				//å½“å‰ï¿??? ç»ˆç«¯è´Ÿè½½æ¥è§¦å™¨Bä½¿èƒ½
}
/* USER CODE END Application */

